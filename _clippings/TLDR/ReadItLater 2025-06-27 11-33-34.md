大家好，欢迎观看新一期视频。我叫 Dan Fya，是 Flowhawk 的 CEO。在 Flowhawk，我们帮助公司使用 AI 自动化其内部运营。在本视频中，我将向您展示我们如何构建一个 AI 列表管理器，用来管理我们目录中的所有列表。

这个列表管理器能够搜索互联网，找到有潜力发布的列表，并为其分配类别和标签。我们还在智能体中加入了反馈机制，所以在将这些列表发布到我们的数据库之前，它会等待我们的反馈。

我们使用 LangGraph 和 Pydantic AI 构建了这个智能体。所以，在本视频中，我将与您分享代码以及我们是如何构建它的。希望在视频结束时，您能对构建这类 AI 智能体有更好的理解。

市面上有许多框架。有像 CrewAI 这样的高级框架，也有像 Pydantic AI 和 LangGraph 这样的底层框架。我个人在寻找构建智能体的最佳框架时也曾遇到困难，直到我看到了 Cole Med 的这个视频。Cole 在解释如何构建智能体方面做得非常出色，你绝对应该去看看他的频道。在他的一期视频中，他解释了如何使用 Pydantic AI 和 LangGraph 这套组合框架来构建智能体。

在亲自体验了一些构建 AI 智能体的挫败感后，我尝试了这套组合，我必须说，它非常强大。一方面，你可以使用 Pydantic AI 构建非常具体的智能体。另一方面，你可以使用 LangGraph 来编排所有这些智能体。所以，最终，通过这两个框架，你可以获得高度的模块化。我所说的模块化是指，你将能够使用 Pydantic AI 构建非常具体的智能体，并且可以独立地挑选每一个智能体，而无需修改其他智能体。然后，使用 LangGraph 可以非常容易地对它们进行编排，你可以将它们连接起来，并决定数据如何在智能体之间流动。

这样一来，扩展你的系统将变得非常容易。例如，你可以从构建一个非常简单的流程开始，然后不断添加新的智能体，而不会影响初始流程的质量。话不多说，让我们进入视频。

### 我们使用的技术栈

在我们看程序本身之前，先谈谈我们将用来构建这个智能体系统的不同框架。

首先，我们将使用 **Pydantic AI**。Pydantic AI 基本上是一个相当底层且易于理解的框架。例如，如果你看一下它的智能体，你会发现只需几行代码就可以定义一个智能体。然后，例如，向这些智能体集成新工具也相当容易。正如你在这里看到的，这是一个带有两个不同工具的智能体，非常直接。

下一个我们将使用的框架是 **LangGraph**。LangGraph 比 Pydantic AI 更复杂，但它是一个非常好的编排框架。在我们的案例中，我们将使用 LangGraph 来让不同的智能体之间进行通信。我不想在这里花太多时间，但 LangGraph 的一些很酷的功能包括：首先，为这些智能体创建记忆（memory）相当容易，你可以暂停工作流程，之后再恢复它，而不会丢失流程的状态。然后是“人机回圈”（human-in-the-loop），这也是 LangGraph 提供的一个非常强大的功能，即你可以在某个点中断流程，允许一些人工输入，然后再继续。

LangGraph 的工作方式是，你必须定义一些节点（nodes），然后在每个节点内部执行一些操作，然后用边（edges）连接这些节点。通过这种方式，你定义了图（graph）的流程。我们稍后会看到我们案例中的图，但这使你能够创建非常强大的结构。

我们还将使用一个名为 **Crawl4AI** 的工具，它非常擅长做网页抓取，你可以轻松地将网站的 HTML 转换成 Markdown。

对于用户界面，我们将使用 **Streamlit**，这是一个开源库，用于制作前端。他们使得集成大型语言模型应用变得相当容易，他们甚至有一些关于如何构建聊天界面的演示，而这正是我们将在我们的应用中使用的。

### 我们的自定义图（Graph）结构

好了，现在我们已经解释了我们将使用的技术栈，让我们来看看将成为我们自定义图的结构。如你所见，我们有七个不同的节点，每个节点都将是一个用 Pydantic AI 构建的 AI 智能体。

1.  **搜索智能体 (Search Agent)**：负责抓取互联网，寻找可能被插入我们目录中的潜在列表。在这里，我们将使用 Crawl4AI，并向其提供一些来源。在我们的案例中，我们使用新闻通讯来寻找新的列表。
2.  **列表筛选智能体 (Listing Filtering Agent)**：一旦搜索智能体完成了搜索新闻通讯并提取潜在列表的工作，我们会将这些信息发送给第二个智能体，即列表筛选智能体。这个智能体会有一些质量标准，并决定搜索智能体提供给它的这些列表质量是否足够好，可以在我们的目录中发布。这个智能体的好处在于它会为我们提供一个置信度分数，告诉我们它对某个特定列表是否符合我们标准的确定程度。
3.  **摘要生成智能体 (Summarizer Agent)**：一旦我们筛选了这些列表，只剩下质量足够高的那些，我们就会进入摘要生成智能体。这个智能体将再次抓取每个列表的网站，并以我们想要的格式提取摘要。例如，在我们的案例中，我们想要提取描述、一些功能、用例以及定价层次等。
4.  **列表分类智能体 (Listing Classifier Agent)**：现在我们有了一些关于列表的信息，列表分类智能体将负责为每个列表分配标签和类别。这个智能体的一个非常特殊之处在于，它将连接到我们的数据库，并获取我们目录中可用的类别和标签。在这里，我们同样会使用置信度分数。这样，我们就可以看到智能体是对自己的工作非常确定，还是不太确定。根据这些置信度分数，我们稍后可以决定是接受列表分类智能体的操作，还是我们想进行修改。
5.  **反馈收集器 (Feedback Collector)**：这就是反馈收集器发挥作用的地方。这个反馈收集器节点基本上会等待人工输入。
6.  **路由器 (Router)**：在提供输入后，会有一个路由器。它可以被看作是一个非常小的智能体，其功能是决定人类是决定修改某些列表——在这种情况下，它会将流程重定向到列表修正智能体——还是人类对所提供的信息感到满意，并希望继续将列表发布到数据库中。这样，它就会将流程引导至发布者智能体。
7.  **列表修正智能体 (Listing Rectifier Agent)** 和 **发布者智能体 (Publisher Agent)**

非常有趣的是，如你所见，这里我们有一个递归循环。这意味着流程将一直卡在这个循环中，除非人类明确表示对列表满意，并希望继续发布这些列表。这是一种非常常用的模式，也是一个非常好的安全措施，因为这样你就可以严格控制流程，并且只有在你给予明确同意时，才允许发布者智能体修改数据库。

### 代码详解

好了，让我们动手看看代码。我将首先向你解释我们项目中的文件夹结构，然后我会逐个文件解释每个文件的功能，最后我会解释你如何自己运行它。

#### 文件夹结构

如果我们看一下文件夹结构，我们看到有一个 `agents` 文件夹，其中每个文件都代表一个将在我们图的每个节点内运行的智能体。我稍后会在主图文件中更详细地向你展示我们是如何连接不同智能体的。

然后我们有我们的 Python 环境，还有一个 `.env` 文件，我会创建一个 `.env` 文件的示例，这样你就可以插入你的环境变量。我们有一个 `.gitignore` 文件，一个 `langgraph.json` 文件，这是一个用于运行 LangGraph Studio 的文件，通过这种方式，你可以看到我之前给你看过的图，并从这里运行它，以便进行一些调试，看看图中发生了什么。

我认为文件夹中最重要的文件是 `main_graph.py`，这里定义了不同的节点以及每个节点是如何连接的。你有一个 `requirements.txt` 文件来安装所有依赖项。然后我们有 Streamlit UI，这是我们将用来与我们的图进行交互的界面。这样，我们就不需要手动去 LangGraph Studio 尝试在那里运行图，而是可以创建一个漂亮的用户界面，以对话的方式与图进行交互。

#### 智能体剖析：以搜索智能体为例

让我们来看看第一个智能体。如果你理解了这个结构，那么你就可以开始构建自己的 AI 智能体了。这基本上就是我所做的，我在这里拥有的所有结构在不同的智能体文件中都是相同的，只是根据我们对每个智能体的功能需求进行了调整。

我们在这里构建智能体的方式是：
1.  **定义模型**：我们在这里使用 GPT-4-mini。重要的是，在你的 `.env` 文件中要暴露一个 OpenAI API 密钥。
2.  **定义提示 (Prompt)**：这里是这个搜索智能体的提示。我们要抓取一个名为 Neuron Daily 的 AI 新闻通讯，并从中提取潜在的 AI 智能体。
3.  **定义智能体本身**：这就是你在 Pydantic AI 中定义智能体的方式。你使用这个从 Pydantic AI 导入的函数，在这里你传入一个模型、一个系统提示，然后你可以选择性地传入一个结果类型（`result_type`）。如果你传入一个结果类型，智能体每次运行时都会以这种类型返回输出。这非常强大，因为这样智能体之间就很容易进行通信。
4.  **分配工具 (Tools)**：然后你可以使用这里的装饰器轻松地为这个智能体分配工具。你使用这个带有工具平面的装饰器，在这里重要的是，你要向大语言模型解释这个工具是用来做什么的，它应该传递什么参数，以及这个工具的输出是什么。通过这些信息，智能体本身将自主决定是否要调用这个工具。

例如，在这里我们有两个主要工具：一个工具抓取 Neuron Daily，另一个工具从特定文章中提取特定内容。现在，智能体知道它有两个主要工具可供使用。

这就是你在 Pydantic AI 中定义智能体的方式，正如你所见，它非常酷，因为它是相当模块化的。

#### 其他智能体概览

*   **列表筛选智能体 (Listing Filtering Agent)**：这个智能体负责接收搜索智能体找到的所有工具，并进行筛选，只保留真正的 AI 智能体。它的结构与之前相同，但系统提示和结果类型不同，会输出置信度分数和筛选理由。
*   **摘要生成智能体 (Summarizer Agent)**：它将接收一系列潜在的 AI 智能体，并从这些智能体的网站中提取我们想要的信息，如描述、功能、用例和定价等。这个文件看起来很长，但其背后的逻辑与我们之前看到的相同。
*   **列表分类智能体 (Listing Classifier Agent)**：这个智能体负责为每个已摘要的列表分配标签和类别。这个智能体有点不同，因为它会连接到我们的数据库，获取我们目录中正在使用的类别和标签。
*   **反馈路由器 (Feedback Router Agent)**：这是一个非常简单的 AI 智能体，它的任务是根据用户的反馈信息，决定下一步是将流程引导至负责修改列表信息的助手（列表修正智能体），还是引导至负责将列表信息插入数据库的助手（发布者智能体）。
*   **列表修正智能体 (Listing Rectifier Agent)**：当用户希望进行修改时，这个智能体就会介入。它会接收用户的反馈和需要修改的智能体数据，并进行相应的修改。
*   **数据库插入智能体 (DB Inserter Agent)**：这个智能体负责将我们从反馈路由器收到的所有 AI 智能体列表插入到数据库中。智能体本身相当简单，但它用来执行这些操作的工具相当复杂。

### 使用 LangGraph 连接智能体

现在我们已经定义了所有的智能体，现在我们来到了实现的最后一部分：连接不同的智能体，使它们能够相互传递信息。这就是 LangGraph 发挥作用的地方。

LangGraph 的工作方式是：
1.  **初始化状态图 (StateGraph)**：首先，你必须初始化一个 `StateGraph` 对象。这个对象定义了流程将拥有的状态。在我们的案例中，我们定义了状态来跟踪用户的最新消息、工具、潜在的 AI 智能体、已摘要的智能体等。
2.  **添加节点 (add_node)**：你使用 `add_node` 函数来不断添加我们图中的所有节点。我们为每个智能体定义一个节点，并指定当该节点被触发时将执行的函数。这些函数可以访问并更新状态。
3.  **添加边 (add_edge)**：接下来，你必须连接这些节点，以决定节点的执行顺序。
4.  **添加条件边 (add_conditional_edge)**：当你在一个节点上，不确定下一个节点是什么，并希望根据某些标准执行一个或另一个节点时，这个函数很有用。在我们的案例中，我们从反馈收集器节点使用一个函数来决定是调用列表修正智能体还是发布者智能体。
5.  **实现人机回圈**：在一个节点中，我们使用 LangGraph 的 `interrupt` 函数来暂停图的执行，它会一直暂停，直到我们在代码的其他地方决定恢复这个图。这需要你在图中启用记忆（memory）功能。

这个流程一开始可能看起来相当复杂，但一旦你理解了这个结构，你就能够构建非常强大的智能体系统。

### UI 界面和调试

#### Streamlit 应用

我们使用 Streamlit 创建了一个聊天界面。这个界面背后的逻辑是运行我们的 LangGraph。我们为每次执行创建一个线程 ID（`thread_id`）。这与记忆功能结合使用，允许你为不同的用户多次运行同一个图，同时为每个用户引用属于他自己的图的状态。

#### LangGraph Studio

在运行智能体之前，我想向你展示图的样子。为此，我们将使用一个名为 LangGraph Studio 的工具，它允许你可视化你构建的图。

要运行它，你首先需要安装相应的包，然后确保你有一个 `langgraph.json` 文件来配置它。之后，在终端输入 `langgraph dev`，它会打开一个新窗口，你就能看到你构建的图了。

在 Studio 中，你可以看到不同的节点以及它们是如何连接的。你甚至可以运行它，并在每个节点执行后看到图的状态。例如，当图到达需要人工反馈的节点时，它会暂停。你可以通过界面提供反馈（以 JSON 格式），然后恢复图的执行。

### 最终演示

现在你知道如何在 LangGraph Studio 中运行你的图了，让我们看看如何运行 Streamlit，这样我们就可以用一个漂亮的用户界面来与图进行交互，而不是在不那么用户友好的 LangGraph Studio 中操作。

（视频演示开始）

我们告诉智能体发布一些列表。
1.  **搜索智能体**开始工作，检测到潜在的待发布列表。
2.  **列表筛选智能体**接收所有这些列表，并只选择那些真正的 AI 智能体。在这个案例中，它识别出了三个，置信度分数分别为 95%、92% 和 90%。
3.  **摘要生成智能体**接收了这些真正的 AI 智能体，并提取了我们想要的所有信息，如功能、定价、用例。
4.  **列表分类智能体**为每个列表分配了类别和标签，并显示了置信度分数。

现在，图正在等待我们的反馈。我告诉智能体，我们想从 Eraser Bot 中移除一个功能，并更改 Mioot 的类别。
1.  **反馈路由器**将流程导向**列表修正智能体**，后者接收此反馈并修改相应的列表。
2.  我们看到，Eraser Bot 现在只有四个功能，我们想移除的功能已被移除。Mioot 的类别也已更改为“客户支持”。
3.  **反馈收集器**再次等待我们的输入。我们要求发布这些列表。
4.  **反馈路由器**为**发布者智能体**亮了绿灯。它接收所有这些列表，并将它们发布到我们的目录中。

它已经发布了这三个列表。现在，如果我们去我们的目录，我们会看到三个新列表：Fathom，带有新分配的“客户支持”类别的 Mioot，以及只有四个功能的 Eraser Bot。

好了，各位，希望你们喜欢这个视频。如果喜欢，请点赞并订阅。我的想法是继续发布我们为 Flowhawk 客户构建项目时学到的知识。Flowhawk 是一家帮助中小企业使用 AI 自动化其内部运营的 AI 机构。如果你是企业主，或者你在一家有自动化需求的公司工作，请通过 flowhawk.com 联系我们，我们很乐意帮助你。
