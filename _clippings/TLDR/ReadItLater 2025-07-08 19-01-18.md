好的，这是为您生成的简体中文语音文字稿。

### 简介：用 Cloud Code 原型化一个任务管理工作流

我想我应该把这个过程录下来，也许对那些刚开始使用 Cloud Code 的人会有帮助。

我正在做的是为一个任务管理系统原型化一个工作流。我在我的 docs 文件夹里有一个我常用的 todo.md 文件，它代表了状态，被分成了已完成项和待办项。

对于待办项，我通常是想到什么就记下来，或者在一次会话中，当我们处理别的事情时，让 Claude 快速在这里记下一项。

我想要的是一个斜杠命令，我可以说“/todo”，然后这个斜杠命令应该能总结出这个文件中所有的待办事项，然后让我选择一个。接着，它会问我是否要完善它，也就是明确“做什么”（what）和“怎么做”（how）。然后，用这个改进后的版本替换掉原来的待-办事项。

改进后的版本意味着里面有足够的信息，我可以让 Claude 尽可能自主地去尝试实现它。但要实现这一点，我需要对这个待办事项本身进行迭代，并作为人类来判断这些信息是否足以让 Claude 完成它应该做的工作。我希望这是一个可重复的过程。所以每当我想开始处理一个新的待办事项时，我都能有同样的工作流。

原型化的一种方法就是直接写一个斜杠命令，并在 Claude 的帮助下改进它。因为 Claude 可以判断你在这里描述的工作流——这有点像一个修改状态的程序——是否真的容易让它遵循和执行。

到目前为止，我已经写了一些蹩脚的东西，但我并不满意。所以现在我正在用 Claude 帮我修复它。

### 用 Claude 完善命令脚本

我需要做的第一件事是，如果这个文件实际上不存在，它应该根据一个模板来创建。

“请添加一个步骤零，我们检查文件是否存在，如果不存在就根据模板创建它。”

看看它现在在看什么。是的，我的提示非常随意。语音转录这种方式很适合这种提示风格。

好了。哦，它已经存在于文件中了。不应该的。让我看看。啊，好的。好吧。再试一次。

我之前有一个比这更好的版本，但我想从这个状态开始，这样更容易看明白这是怎么运作的。

嗯，这听起来不错。好的。

### 改进步骤一：选择任务

好吧，我们需要改进步骤一。它现在甚至没说我们应该把从待办文件中读取的待办事项呈现给用户，并询问他们要选择哪一个。

我的设想是，当我们向用户展示所有待办问题或待办事项时，我们应该给出简短的摘要，可能是一行的摘要。然后停下来，问用户他们想处理哪一个。并且展示时最好是编号的，这样用户就可以说“我选第一个”。

之前我已经在这里写了一些东西，说“使用带有 RG 的 bash 工具”，这样它就不会去用一些慢的或者不工作的工具。我们想优化它，让它只读取待办问题，而不是读取文件的其他部分。

它说，“读取我们的博客内容，嗯，对我来说，将所有待办事项以编号列表的形式呈现给用户，附带一行摘要，然后停下来问‘你想处理哪个待办事项？请输入数字’”，好的，就像一个文字冒险游戏，“然后等待用户选择。”

好的，很酷。

### 改进步骤二：完善任务（“What” 和 “How”）

接下来就是完善阶段了。这其实是胡扯。我想要的是，在用户选择了待办事项之后，我想……好的，在用户选择了待办事项之后，我们想把完整的、一字不差的原文展示给他们，就像它在 todo.md 里那样，然后问他们是否想完善它。

如果他们想完善，我们应该弄清楚“做什么”（what）和“怎么做”（how）。

“做什么”意味着我们需要不断提问，直到待办事项的描述得到改进，也就是我们实际上想在功能上或行为上实现什么。

而“怎么做”基本上就是你通过任务工具启动一个或多个任务代理，它们会调查代码库，找出我们需要在代码库的哪些地方进行更改、更新、删除等等。其结果应该是一个简洁的文件列表和需要对这些文件进行的更改列表，这样你将来就可以读取这个待办事项，并准确地执行实现这个功能所需的一切，大部分是自主完成的。

好了，希望这个随意的提示足以改进这一点。

好，让我们看看它做了什么。“停下来问‘你想要完善这个待办事项吗？’”啊，好的，所以它更新了第一步。它说“等待用户选择，显示所选的待办事项，停下来问，如果回答‘否’，则跳到第 3 步。否则，完善待办事项，仅当用户说‘是’时，澄清‘做什么’，即功能行为，要求并提问以理解需要实现什么，继续直到描述清晰完整，专注于行为而非实现。”

对，所以这需要用户再进行一次确认。步骤 2.A 需要用户的确认步骤。

所以，一旦你认为你已经收集了所有的需求，就向用户提问，给他们一个你认为“做什么”应该是什么样的总结，以我们稍后将写入 todo.md 的形式，并询问他们这是否是他们打算做的。

对于“怎么做”，我们也应该做同样的事情。所以一旦你认为你已经收集了足够的信息，就以我们稍后将写入 todo.md 的形式呈现出来，并询问用户这是否对他们有意义，或者这是否是他们同意需要做的。

好，让我们看看。“一旦完成，以用于 docs/todo.md 的格式呈现澄清后的‘做什么’，停下来问这个情况是否准确。如果不准确，继续澄清。以用于 todo.md 的格式呈现‘怎么做’的发现，停下来问这个实现计划看起来正确吗。如果否，收集更多信息或进行调整。”听起来还行。

找到完善后的待办事项，显示澄清内容，如果用户确认则继续。

所以我想在 2C 中，我们需要确保在用户确认后，你被指示要用新的待办事项替换掉旧的。我的意思是，它在“更新 docs/todo.md 之前”这句话暗示了它应该这样做，但在这里有一个明确的步骤来做这件事通常更好。“使用编辑工具用完善后的版本替换旧的待办事项，保持相同的复选框格式，只有在成功更新后才进行到第 3 步。”嗯，听起来不错。

### 改进步骤三：实现任务

好的，我想“实现待办事项，遵循现有的测试流程，将项目标记为已完成，并附上关于哪些文件已更改的说明。”嗯，我猜我们也可以改进这一点。

好的，让我们来处理步骤三。我在 `docs/` 目录下有一堆文档。不确定我们是否想把它们放到编码代理的上下文中。让我们看看。

所以实际上，待办事项的“怎么做”部分应该给机器，也就是 LLM，足够的信息，让它不至于偏离主题太远，重新调查整个事情。

好的，假设待办事项里有我们需要调查的所有文件名、路径和行号，一旦我们实现这个待办事项，我认为我们不需要 LLM 去读取文档。但它需要知道的是如何进行类型检查、代码风格检查和格式化。所以它应该在每次更改后都这样做，以确保事情没有搞砸。它还需要知道如何构建和如何测试。测试目前是未定义的，所以我们可以在稍后看看如何将它整合到斜杠命令中。

“将项目标记为已完成，并附上关于哪些文件已更改的说明。”嗯，我想在一个待办事项实现后，我们会提交并推送它。所以我认为我们只需要更新待办事项，链接到那个提交。我们还需要将待办事项移动到文件顶部的已完成项部分。

对文件的所有操作，比如更新 todo.md，都必须高效，所以要明确告诉 LLM 如何做到这一点。

再次，非常随意。让我们看看会出来什么。当它在做这个的时候，让我看看……控制器中的会话应该按……让我们先实现这个。实际上我们可以保留这个，我们想稍后实现它，所以我们将会看到项目选择是否按预期工作。

“使用完善后待办事项中的文件路径和行号进行更改。”呃，这太糟糕了。是的，“使用完善后待办事项中的文件路径和行号进行更改”有点糟糕，因为这意味着 LLM 仅限于做这些。它更像是 LLM 可以用来实现待办事项的代码库指南。它应该可以自由地探索其他文件，而且对于某些待办事项，我们可能甚至没有需要修改的文件，而是需要创建新的。所以请以一种能确保 LLM 理解待办事项中的“怎么做”部分更像是一个指导，而不是一个严格的护栏的方式来修改它。

让我们看看，每次文件更改后运行……是叫 `check` 吗？我想是叫 `check`。嗯，那看起来还行。`npm run check` 这个东西很酷。如果我们修改 Swift，我们需要调用构建守护进程任务。所以 `npm run check` 用于 TypeScript 的东西，而 `npm run build:daemon` 用于 Swift 的东西。

“一旦你的实现完成，提交所有更改，提交信息是‘实现待办事项’，推送到远程，从输出中获取提交哈希值，使用编辑工具添加逗号，链接到……”嗯，更新 `docs/todo.md` 的效率问题很糟糕。它应该是“从‘待办’部分移除这个待办事项”。我不确定如何高效地做到这一点。用你的工具，我想用一个空字符串替换掉一字不差的待办事项字符串应该可以。然后我们需要把这个待办事项作为已完成项添加到顶部的已完成部分，所以我们只需要从第二行开始插入，并在描述中加入提交的哈希值，我猜是这样。如果你能找出 GitHub 的 URL 并把它也放在那里，那就太好了，这样我们就可以直接访问网站，查看起来更方便。

哦天哪，把它放到……在错误的窗口里转录了，这可不好。

好了，我们来了，让我们看看它还做了什么，“使用编辑工具把它粘贴到已完成部分的末尾。”不，那不是我们想要的。不要重试……嗯，好的，那没问题。

让我们看看它是否能真正更新那个。在它做的时候，我可以快速向你们展示我们想实现什么。

我这里有这个小东西，它列出了所有当前正在运行的 Cloud 会话。这是一个正在进行中的大工程。这个会话当前正在工作，所以它被标记为绿色，它在做一件事，如果它没在做什么事，它就被标记为橙色，这意味着它在等待输入。它也在这里显示，并且应该显示一个通知，但我目前关掉了。而且……哦，实际上没有通知显示，因为我们在录屏，就是这个原因。我希望这些……如果进程退出了，就像这样，它应该变红，我希望。哦，我还没实现那个。哦，现在它只是把它移除了。是的，我还没实现。清除所有……嗯，没关系。

不管怎样，我的意思是，我们有绿色代表工作，黄色代表等待提示，红色代表已退出。我希望它们能被排序。所以我们稍后会用新的待办系统来实现这些。

### 审查与迭代

让我们继续。它在这里做了什么？我想我需要重新加载这个。是的，不保存。这是关于这个工具不太好的地方之一。当 Claude 写入一个我打开的文件时，我在这里输入了东西，但即使我在它写入之前回到了旧版本，事情也会变得很奇怪。

“使用待办事项中的‘怎么做’部分作为指导，而不是严格的规则。可以随意探索文件，并在需要时创建新文件。修改文件后，运行适当的检查。一旦完成，提交所有更改。推送提交，获取仓库的提交哈希值。更新文档。使用带有 `replaceAll: true` 的编辑工具从待办部分移除该待办事项。使用编辑工具在第二行插入已完成的待办事项。”

好的，在第一步的末尾我们只说了描述。我想要把完整的待办事项放到已完成部分，这样我就可以追踪我做了什么。

让我们看看，还有别的吗？哦是的，在第一步的顶部，我们需要确保 LLM 理解它应该遵循它在正在修改的文件中看到的编码风格和模式。我想这实际上已经在 Claude Code 的系统提示中了，但多说一句也没坏处。这并不意味着我们不需要在提交前手动审查它做了什么，这是我们需要添加到第 3 步的另一件事。至少我是这么工作的，因为我想理解代码。

好吧，我想我又修改了这个，所以我得……是的，就是这样。“构建时，遵循你正在修改的文件中的所有编码风格和模式，使用‘怎么做’部分。”这很好。“完整的待办事项内容，包括‘做什么’和‘怎么做’。”嗯，这看起来不错。

好的，这是一个不错的初步版本。现在我们只是缺少这里的确认步骤。

“请在提交前，增加一个确认步骤，要求用户审查所有文件。”“指示 LLM 使用 vs-claude 扩展来在 VS Code 内部显示每个被修改文件的工作区和 HEAD 之间的差异。”vs-claude 是我写的一个扩展，这样 Claude 就可以在 VS Code 中打开文件和差异。嗯，我想那应该可以。

所以这看起来像一个相当完整的工作流，我想。现在我们可以快速测试一下。

它做了什么？反向的。完美。它显示了它需要的确切内容。

哦，告诉代理它实际上可以在一个 vs-claude open 调用中打开多个差异。这样我们就不会浪费回合。所以我们不会为每个文件都用一个回合来打开它，而是在一个回合里，希望 LLM 能做到这一点，传递一个要打开的东西的数组。因为老爹我可不想等。

我想我们搞定了。把这个命令添加到 git。也把 todo.md 添加到 git，然后提交并推送这两个文件。让我们看看我们是否还有其他修改。我不认为有。不，看起来不错。

### 实战测试

好了，现在我们可以尝试实现其中一个待办事项了。我有一个 development.md，也是由 Claude 生成的，我做了一些非常小的改动，因为我懒得去读这个。这可以是在第三步中注入的东西。哎呀。在这里，只是为了让它知道代码库的结构，但我不确定我们是否应该添加它。让我们不加试试，看看它做得怎么样。一旦待办事项的完善完成，我想这可以很好地替代 development.md。另外，在我们在处理事情时进行检查方面，这看起来还行。

好了，让我们开始一个新的会话。我就用斜杠命令。斜杠命令不在这里。怎么回事？

嗯，让我们问问 Claude。“我把一个斜杠命令放在 `.claude/commands` 里了。为什么它没有在 Claude Code 中显示出来？”

我的语言太糟糕了，以至于我用来做语音转录的模型 Whisper 总是以为我说的是“Cloud”而不是“Claude”。

“Claude Code 查找自定义命令。我们需要移动……”嗯，别那么做。谢谢，现在你把它放到了我的主目录里。请撤销那个。

我们也可以有项目本地的斜杠命令，我们……好的。你正在启动你的 Cloud 会话，确保文件有 .md 扩展名，检查命令名是否与内置命令冲突。哦，是的，那可能是……不，它实际上应该显示为 `/`。让我们看看。`mario/todo`。让我们重启这个。`mario/todo`。啊哈，有趣。如果我之前改了这个，它会是项目名，然后是命令名。我明白了。有趣。但是没有 `todo` 这个斜杠命令，所以我就再试一次 `todo`。我应该读读 Claude 的发布说明。

`/todo`

是的，完美。所以，让我们看看。根据我的计算，它应该首先检查这个文件是否存在。如果 `ls`，它存在。不，它在……让我们看看，是第 3 行吗？这正确吗？是的。读取内容。`todo`。它是从第 3 行开始读的吗？读取偏移量 3，很好。

这是待办事项：
1.  按状态对控制窗口中的会话进行排序。
2.  检查并显示会话监控持续时间。
3.  将“全部清除”更改为“清除已退出”。
4.  按状态对控制窗口中的会话进行排序。（重复了）

嗯，让我们先做这个，因为为此我们还需要跟踪已退出的进程。这主要是在 Swift 代码库中。

“你选择了待办事项 1”，所以它现在向我展示了原文。是的，当然。我们让它完善一下。

“看了一下待办事项，我注意到有个拼写错误。嗯，好吧。当你说‘控制窗口’时，你是指一个特定的 UI 组件吗？”

这是控制窗口。是的，它现在读取代码没问题。所以，`README.md` 和 `Source/Mac/Daemon`，我想是的。是的，`Daemon.swift`。

我有个更好的主意。这实际上是一个有趣的观点。所以当我开始一个新会修时，它完全不知道这个项目是关于什么的。所以我们或许应该把这个加到这里。哦，天哪，我需要像只猿猴一样用键盘打字。哦，它用了一个任务。哦，那真好笑。花了 21000 个 token 就为了读两个文件。

好的。“现在我比刚才更了解这个应用了。待办事项有个拼写错误，而且似乎提到了状态。根据代码，它们并没有准确地提到当前的实现。有工作和空闲状态。当前实现中没有明确的红色‘已退出’状态。这是对的。死掉的会话每五秒会自动移除。一个新的‘已退出’状态。是的，我想添加一个新的‘已退出’状态。所以我们不是每五秒移除它们，而是在内存中将它们标记为已退出。而不是自动移除它们，这意味着会话会存在，并且会变成红色，可见的。你可以手动清除这些会话。完全正确，那个叫‘全部清除’的按钮现在应该叫‘清除已退出’，并且只移除已退出的会话，也就是从内存存储中移除它们。排序顺序应该是……这没问题。会话是否应该显示它们退出的时间戳？我们对保留多少有限制吗？”

我们没有限制。我们暂时不需要跟踪时间戳。那是稍后的另一个待办事项。过一段时间后。不，不，不，清除应该是手动的。

“我完全理解了。让我为这个待办事项呈现一个澄清后的‘做什么’。”

让我们看看。
*   为已结束进程的会话添加一个新的“已退出”状态。
*   在内存中标记会话为已退出，而不是移除它们。
*   不自动清除已退出的会话。它们会一直保留直到手动清除。
*   在控制窗口中按状态排序会话。
*   将“全部清除”按钮更新为“清除已退出”。只从内存存储中移除已退出的会话。保留工作和空闲状态的会话。

是的，完美。所以它现在进入了这个阶段。并且应该继续调查“怎么做”。它正在启动一个任务代理来做这件事。这是提示。让我们看看我们能不能看到完整的东西。不，我们看不到。哦我的天。Cloud Code 有个错误。哦我的天。我回不去了。哦，这太糟糕了。啊，天杀的。现在我们得重复这个了。看来是这样。啊，天哪。保存。继续有帮助。好的，很好。

好的，看起来 `Control+R` 可以工作，但 `Control+E` 会进入一个无法恢复的错误模式。哦，该死的。我讨厌它们不显示任务在做什么。让我们不要按 `Control+E`。所以这是提示。它告诉代理，分析代码，请理解如何实现会话。按状态排序，专注于……管理、渲染控制、渲染 UI、会话清理、移除发生的地方。查看需要的具体更改类型。返回需要更改的文件路径。嗯，听起来不错。

让我们看看。哦，这花了很长时间。让我检查一下。啊，完美。28000 个 token。所以读取 `README` 和 `Daemon.swift` 花了 21000 个 token，而做一个完整的代码库分析花了 28000 个 token。这说得通。

这是“怎么做”：
要修改的文件：
`Daemon.swift`:
*   在 `SessionStatus` 枚举中添加 `exited`。
*   更新 `removeDeadSessions` 方法。我应该告诉它。是的，我讨厌这个。它应该输出完整的文件名，冒号，然后是行号，但是，呃，算了。我们就这样吧。很容易看出来。所以更新 `removeDeadSessions` 方法。不是移除死掉的会话，而是将它们标记为已退出。
*   当会话排序时。嗯，听起来不错。`sortSessions`，第 69 行。让我们看看。所以会话是按时间戳排序的。啊，有趣。是的，那说得通。
*   `clearAll`，第 355 行。好的。是的，改那个。删除所有。
*   为已退出的会话添加视觉上的区分。在第 42 行之后。嗯，我猜是。添加不透明度修饰符，使已退出的会话看起来褪色。

嗯，听起来很棒。“它看起来提到了吗？”是的，看起来太棒了，我的朋友。

好的。所以按照我们斜杠命令的工作流，它现在应该使用编辑工具用完善后的版本替换旧的待办事项。让我们看看。哦我的天。哦是的，“应该用这个完善后的版本更新 `docs/todo.md`。”是的。完美。爱了。

好的。我想我之前又修改了这个。太好了。这正是我想要的。现在让我们进行到实现阶段。听起来不错。哎呀。让我们改一下。

所以，实现，它做了什么？它没有读取 `Daemon.swift` 的全部内容，这不理想。而且，问题是这需要，实际上，它需要复选框吗？不，我想没关系。我想如果我们必须恢复，那么当它再次遍历所有这些并看到我们已经做了更改时，它只会说，“啊，这个已经完成了。”所以这些复选框作为状态跟踪器应该足够了，我猜。

啊，有趣。所以它没有考虑我们实际写出的信息。排序，做这个，然后按时间戳，这说得通。是的，是的，是的。看起来不错。

与此同时，我可以看看 Hacker News 或者别的什么。我只是想看看它在做什么。那对你们来说可能更有趣。

是的，不透明度的更改，然后应该就完成了。现在运行检查并修复任何问题。啊，“全部清除”按钮。是的，我想这需要，那需要复选框。

### 再次迭代工作流

让我们看看。让我们打开一个新的会话来通过 Claude 编辑我们的斜杠命令。让我们看看。那排除了外部会话。它有自己的待办列表没关系，对吧？但我们绝对想要为“怎么做”的部分添加复选框。

哦天，哇，这他妈是什么？这是什么？哦我的天。我也讨厌 Claude 自动更新。这太糟糕了。编辑菜单项并找到 `clearAll` 方法。不，那不是我们想恢复的。

好的，这是我们想恢复的，自定义命令，我要做的是，我们生成的“怎么做”应该为每个“怎么做”项都有一个复选框。在实现过程中，LLM 应该勾选那些复选框并相应地更新 `todo.md` 文件。这样我们就可以跟踪 LLM 实现“怎么做”项的进度。请相应地更新 `.claude/command/todo.md` 文件。

好了，这个小家伙。“请审查更改。”好的，酷。

所以它通过我的小 VS Code、VS Claude 插件打开了 `daemon-swift` 的 git diff。所以我们添加了一个新的会话状态，`exited`。我们先按状态排序，然后按时间戳。我们在这里做什么？移除会话。我们检查它是否死了。如果它死了并且状态还不是 `exited`，那么我们把会话标记为 `exited`。或者更确切地说，我们记录下我们把它标记为 `exited`。把它标记为 `exited`。听起来不错。不移除它。

下面是什么？我们把按钮从“全部清除”重命名为“清除已退出”。移除所有，然后传入……让我们看看。好的，那只是过滤会话并移除所有已退出的。状态图标现在有三种状态。不透明度更改，这样死掉的或已退出的会话会褪色。清除已退出。那只是回调的设置。就是这样。是的，完美。看起来太棒了。是的，爱了。

我们不测试。我们在生产环境测试。

### 最终测试与结论

好的，让我们看看我们在这里做了什么。“呈现格式文本，实现步骤应该……”嗯，这个不错。它完成了吗？更新它。好的，那很好。完美。

有了这个，我们应该有一个全新的显示控制中心了。这里现在有两个。我不确定这是否已经是最新版本的控制中心了。所以这个更改已成功提交。让我们看看如果我们杀了这个。不，还不是最新的。这是旧的，会移除已退出的会话。让我们试着杀了这个，然后我们应该能得到最新版本。它构建了吗？让我们看看。是的，它构建了一个新的守护进程。所以现在这个应该是新的守护进程了。

然后我们只需打开一个新的 Cloud 会话。这是现有的一个。它还在工作。所以它说没有消息。这个下一步需要更新。进入待办事项。然后我们说“say hi”。现在我们应该在这里看到一个东西。是的，它说了 hi，现在是黄色的。现在我们杀了它，它应该变红并移动到列表底部。它没有移动到列表底部。该死的。

好吧，这是稍后要修复的一个 bug。但看起来系统是工作的。现在它在底部了。有趣。

哦，我们搞定了。再见。
