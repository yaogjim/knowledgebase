好的，这是为您生成的简体中文语音文字稿。

---

## 十年回顾与新的挑战

哈喽，哈喽。

好的，我的幻灯片已经显示出来了，你们都能看到，对吧？是我。

好的，这对我来说是一个非常特殊的时刻，因为我昨天走进这里时才意识到，这正是我十年前，几乎是同一天，站上的同一个地方、同一个舞台，为 DockerCon 2015 拉开序幕。我觉得这很有趣，不知道当时是否有人在场？或许这里的观众太年轻了，我不知道。

好的，我今天来这里是为了谈论“混乱”，特别是当你尝试使用编码智能体时出现的那种混乱。我想从我们 Dagger 社区的视角来谈论这种混乱，我们是平台工程师。不知道在座有没有平台工程师？好的，只有我和这位女士。

好吧，众所周知，平台工程师有时也被称为其他名字，但基本上，平台工程师的工作非常艰难。因为他们不是去构建和交付酷炫的软件，而是去赋能你们所有人，让你们能够以最高效的方式构建和交付酷炫的软件。这是一项非常艰巨的工作，需要广博的知识、丰富的经验和极大的耐心。

但我们这么做，是为了那无尽的满足感，你知道，就是从开发者那里获得的感激。开玩笑的，从来没人说过谢谢。不过没关系，总得有人做这份艰难的工作。

## 平台工程师的新工作：服务于机器人

说到赋能，这里有人使用编码智能体吗？我们是少数派。

好吧，我想对你们说，恭喜你们，欢迎加入平台工程领域。是啊，我的意思是，你们现在的工作就是赋能机器人去交付出色的软件，而你们自己则花费越来越多的时间去帮助它们高效地完成工作。这工作很艰难。我为你们鼓掌，因为你们放弃了这份工作中真正最有趣、最有回报的部分，你们真是无私啊。

当然，这还不完全是现实。我们还没有一个智能体团队在那里嗡嗡作响地工作，而我们则坐在一旁为它们修复环境。但你已经能预见到这一天的到来，对吧？你们中的一些人肯定已经在尝试和实现这一点了，网上有很多很酷的帖子、脚本和工具。

所以我们知道它终将到来。问题是，我们如何让这件事不仅为这群极其酷炫和走在技术最前沿的人实现，而是为所有人，为每一个交付软件的人实现，通过赋能智能体为他们工作，最终取代他们的工作，来创造最大的价值。这才是梦想，对吧？

## 当前的困境：两种糟糕的选择

好的，那么我们该如何做到这一点，并且让过程不那么痛苦呢？

我想回到基础，什么是智能体？当然，著名的定义是：一个代表人类，在循环中把一切搞得一团糟的大语言模型（LLM）。哦天，这本该是个动画的，有动画效果会更好。没关系。

你有一个智能体，它在你的环境中，也就是你的电脑上，做着各种事情。它能做出很棒的工作，也可能做一些非常疯狂的事情。所以你必须密切关注它，不断批准、批准，“不，别那么做，那太疯狂了”，“是的，这个可以”。

这差不多是今天的现状。但我们当然想扩展它，我们想要一个团队。那我们该怎么做呢？

我认为目前有两种选择，都同样美妙和有趣。

第一种，我称之为“YOLO 模式”（You Only Live Once）。我就直接运行十个，能出什么事？神奇的是，这张图还不是最坏的情况。但你懂的，那种密切监视的方法很快就失效了，因为它们会互相干扰，共享同一个环境。

好的，于是出现了第二种选择。“哦，别担心，我们来运行这些智能体。”我们会搞定一切。我们有后台模式，我们有模型，有工具，有环境，有计算资源，有密钥，我们什么都有。你只需要提个 issue，然后等着 PR 就行了，放轻松。直到，它当然会出问题，然后你就会说：“不，我不是这个意思。”

这些方案其实效果很好，我觉得光是今天和昨天就发布了十几个。它们很棒，只是有时候，你就是想亲自上手，“好吧，把键盘给我”。有时候你就是想在自己的机器上，或者在你喜欢的计算服务商上运行它，使用你喜欢的模型，你想混合搭配。所以这种一体化的模式有其局限性。

## 我们真正需要的是什么？

问题是，有没有更好的方案？有没有一种场景，我就是拥有一个团队，他们在工作，我可以随时介入，也可以让他们自己干，我们一起把事情搞定？

我会这样总结我想要的东西，基本上是四点：

第一，我想要**后台工作**。我不想守在那里看着每一个动作，这很明显。

第二，我想要**护栏（Rails）**。这意味着我希望能够约束智能体，不让它做那些我已经知道没必要做的事情。比如一些显而易见的东西：项目的上下文、我们的编码风格、要用什么工具，还包括如何构建、如何测试、我们使用的基础镜像是什么，你可以访问这个密钥，可以访问那个。我需要一种简单的方式来设置这些，否则我会在不断纠正它的过程中浪费无数的 token。

第三，当我真的需要介入时，我需要一种非常高效和**无缝的介入方式**。它不能是监视每一个动作，也不能是只等着 PR 然后做代码审查。我需要一个中间地带。

第四，我想要**可选性（Optionality）**。因为就像我之前说的，这是一个疯狂的市场。有很棒的模型，很棒的计算资源，很棒的基础设施，智能体本身也非常酷。而且，就算它们现在已经很酷了，可能你们中的某一位现在就在发布一个新的。明天又会有一个新的。所以我真的不想在今天就把自己锁定在一个完整的方案里，提前对明天可能出现的一切说“不”。尤其是在这个市场里。

为了得到这些，我需要一个具备相应特性的环境。它需要是**隔离的**，这样后台工作才能正常进行。它需要是**可定制的**，这样我才能设置那些护栏。它需要支持**多人协作**，这样我才能说：“好了，让我来，我来修一下”，或者检查一下：“你真的做了吗？”当模型说“我做完了”，你真的做了吗？最后，它应该是**开放的**。不是说赚钱和扩展一个巨大的云服务有什么不好，那很棒，我们自己也有一个，它们都很棒。但我只是想要选择权。我希望能够为每项工作选择最好的商品化组件。甚至它可能是开源的，谁知道呢，我们可以在这上面合作。

## 答案：容器的力量与 “Container Use”

所以，也许不出所料，我现在要谈谈容器了。有人还提醒我，“你应该确认一下他们懂不懂 Docker，懂不懂容器”。好的，谁知道什么是容器？谁用过容器？好的，酷，酷。这让我自信心提升了一点。

但重点是，我们已经拥有了这项技术。它不仅仅是关于容器，但容器确实扮演着至关重要的角色，因为它是一项基础技术，而且它没有被充分利用。我们没有完全发挥这项技术的潜力，因为我们习惯了为人类设计的第一代工具。Git 也是一样，我看到很多利用 git worktree 来完成工作的奇技淫巧。有人玩过 git worktree 吗？好的，你们懂我说的。

这就是关于这个的。当然，我们还有越来越聪明的模型，它们能够非常充分地运用这些技术。我们只需要以一种原生的方式将它们集成起来，这样我们才能真正解决手头的问题，也就是为这些智能体提供优秀的环境。

那么，如果我们构建了这种原生集成，它会是什么样子？

嗯，我们有一个想法。抱歉，在 Dagger 公司，我完全忘了提我的公司名字了，没关系。它很棒，去看看吧。我们对这个问题有一个看法，我们称之为 “Container Use”。你知道有“computer use”（计算机使用），“browser use”（浏览器使用），这些智能体需要 “Container Use”（容器使用）。它们需要一种使用容器来创建环境并在其中工作的方式。这和沙箱（sandboxing）不是一回事。有很多方法可以在一个安全的沙箱里执行智能体的输出，这非常有用，非常酷。但这和让智能体完全在容器内部进行开发是两回事。这才是我们正在谈论的。

## 现场演示（风险自负）

所以我问我的团队，“嘿，我们一直在开发这个东西，它是开源的，但还没完全开源，因为它还没完成。但我应该展示一下吧？”他们说，“绝对不行，还没准备好。”

所以，你们想看演示吗？好的。

好吧，我们说清楚，这代表你们同意看我磕磕绊绊地演示一个未完成软件的有问题的 demo，对吧？好的，现在任何事情都可能出错。

这是我的终端，你们能看到吗？出于技术原因，我不会全屏，当我到屏幕边缘时你们提醒我一下。哦等等，我能看到，没事了。好的，老派做法。我们以前总是这么干的。

好的，我要做的就是尝试开发一个非常简单的东西。我这里有一个空目录，我打算为我这个超赞的 “Container Use” 项目做一个小主页。我准备用 Claude Code，并且尝试用好几个。我希望把一件事说清楚：**这不是一个编码智能体，而是可移植的环境，你可以把它附加到任何编码智能体上。** 这才是重点。所以你喜欢 Claude 就用 Claude，喜欢 Codex 就用 Codex 等等。在 IDE 里，在命令行里，怎么都行。当然也可以在云端，在 CI 里。一旦你实现了异步，就可以做很多很酷的事情。

好的，团队不让我做演示的原因之一是，我用 Claude 真的很烂。我有个别名，用来记住那个禁用所有权限的参数，我老是记不住。我这里有一个提示词，我待会读给你们听，但基本上就是：给我做一个主页，用 Go 写一个 Web 应用，这样我能看懂发生了什么，因为我不是写 TypeScript 的酷小孩。然后写完之后运行这个应用。

在它运行的时候，或者说，希望它能运行的时候。好的，酷。

现在发生的是，我配置了 Claude Code，通过 MCP（Model-driven Command Protocol）来使用 “Container Use”，也就是真正地使用容器。这是一个 MCP 的集成，我们还在做其他的集成，但 MCP 是一个显而易见的起点。所以现在它拥有了所有常规工具，这是原生的 Claude Code，但它现在可以为自己创建一个环境了。现在它正在那个环境里编辑文件，就像在一个小沙箱里。它还可以运行命令来构建、测试，当然还有在临时容器里运行它。这里不是一个一直存在的 Docker 容器，而是每当需要执行一个动作时，就会有一个临时的容器运行，然后被快照，然后返回。所以它就在那里做自己的事。

我想给你们看的是……好的，首先我展示一下，我的工作区没有被任何东西污染。一切都发生在一个小沙箱里。这个沙箱的工作原理是，这些文件的状态和运行的容器，实际上都持久化在 Git 里。它们是一堆特殊的 Git 对象，和代码仓库并存。所以如果我需要，它就在那里，全都在本地。但默认情况下，它不会污染我的工作区。

希望它很快能产出点东西。在它工作的时候，我用这个小命令行工具，这个能看清吗？好的。这个小命令行工具叫 `cu`，就像“see you later”，但不是，它其实是“Container Use”的缩写。我可以用它列出环境，你可以看到这里创建了一个新环境，带有一个随机的名字。我能做几件事，其中之一是打开一个终端。好的，这部分是由 Dagger 驱动的，但我们把 Dagger 当作一个工具箱，它有你需要的所有原语。

所以在这里，我能看到和智能体完全一样的东西。文件，还有工具。我能看到，“你给自己配置了哪个 Go 版本？”好的。因为模型，也就是智能体，被赋予了能力去判断自己需要什么样的环境，然后以一种可重复的、容器化的方式来配置它。所以我在这里可以看看，它能构建吗？好的，能构建。所以你已经完成了？怎么回事？

好的，与此同时，我还要展示另外两件事。第一，一个我不会展示的超酷功能是密钥（secrets）。你可以直接从像 1Password 这样的工具里接入密钥。我用 1Password，我不想用 AI 公司提供的另一个密码管理器，没有冒犯的意思。我只想用我自己的密码管理器。所以我可以直接接入，然后说“这个环境可以获得这个密钥”，然后它就可以用了。然后团队说：“求你了，别展示那个，那个肯定会崩。”所以我就不展示了。

另一件我想说的是，因为它完全由 Dagger 驱动，重点是它是容器化的，是开源的，所以它其实是在我的机器上运行。哦不，它不是在我的机器上运行，因为我们现在在开会，如果你在现场运行容器、下载镜像，可能会有很多问题。所以我把它放在了我家地下室的家庭服务器上运行，大概离这里一英里远。它就是无缝地工作，文件流式上传、下载，一切都很顺畅。

好的，这部分是我无法控制的，你们懂的。

我再展示一个东西，你可以 `watch`。这里我能看到历史记录。在幕后，每一次状态的快照都像是一个 `git log`，它底层就是用的 Git。所以如果我对结果满意，我就可以去把它拿过来。这就像一个恰到好处的协作循环。它不是监视每一个工具的调用然后破坏共享环境，也不是等待一个 Pull Request 然后进行漫长的来回沟通。它就在中间，我能看到发生的一切，然后说：“好的，给我那个历史版本，我想要那个。”

它说已经上线了，正在运行。哦，很漂亮，酷。

好的，现在……我感谢大家的掌声，但你们可以诚实点，这有点无聊。这个设计很无聊。让它“亮眼一点”，我想给一位工程师留下深刻印象。

我这么做是为了创造一种需要大量并行实验的场景。“让它亮眼一点”是什么意思？可以是任何意思。如果我想并行尝试几个实验呢？所以我就说……等等，在我做这个之前，我要先合并这个。这里虽然还是空的，但我要说我喜欢它。所以我说，合并那个环境。现在我就有了它，这是我的历史记录，我可以开一个 Pull Request，可以清理一下，怎么都行。这是一个我能接受的工作循环。

现在我可以说，“不行，太无聊了”。然后因为环境现在处于这个状态，我可以向其他几个智能体求助。我可以对 Claude 说，“YOLO，这个 web 应用看起来有点无聊，能让它亮眼一点吗？”然后对其他智能体也一样。

好的，这就是事情开始真正出问题的地方。但正如团队指出的，他们说：“总会有东西出错的，对吧？”他们说：“是的，但你正好可以展示，如果出错了，你可以直接扔掉那个环境，一切都好，可以重新开始。”我说：“好的，这很酷。”

所以，比如说我不喜欢这一个，我就说：“不要了，再见。”就这样，我不需要去收拾残局，这就是重点。

好的，这开始有点乱了。哦，我还想展示 Goose，Goose 是一个很酷的开源智能体。哎呀，等等。Goose YOLO，同样的话。每个人都有复杂的参数来禁用所有这些安全措施，而我现在已经不需要它们了，因为它……好的，好的。这真的是在冒险。

在它运行的时候，有一件事我们一直在做，但还在开发中，就是我之前展示过的 `watch` 命令。当这些智能体工作时，这是一个 Git 命令，只是简单包装了一下。我们的用户体验，我真的无法用言语表达它有多么不成熟。但它会快速迭代，因为它的底层基础很扎实，是 Git，是 Dagger，而且是你已有的智能体。然后再加上一点胶水代码。所以，举个例子，这里，这真的是一个可以复制粘贴的 Git 命令。当智能体工作时，你会看到状态被快照，你会看到这些分支不断分叉，然后我可以对它们进行 diff、应用、合并，做任何我想做的事。

我真正想展示的，然后我就结束了，就是我想看到其中一个运行起来。这样你们就能看到，当智能体运行一个服务，比如这里的 `go run` 或者 `npm run`，它是在自己的容器化环境中做的。这会无缝地隧道连接到我的机器上，在一个不同的端口上，没有任何冲突。所以当我说环境是隔离的，它指的是文件、上下文、配置和它的执行环境。更酷的是，所有这些技术上其实都在我的地下室运行。所以你可以在基础设施层面玩出各种花样，比如你可以在一个集群上运行它，我们喜欢在 CI 里运行这些东西。有很多好玩的事情可以做。

我还有 30 秒。哦，Goose 正在运行，太棒了！我们还没解决提示词工程的问题。“做吧！”还没完，还没完。哦天哪。

好吧，你们就想象一下吧。

好的，既然我只剩 30 秒了，我就说，谢谢大家。还有最后一件事我想说，关于十年前的 DockerCon。我们以前经常在舞台上开源东西。所以如果你们愿意，我现在就可以把它开源。

好的，不过我已经警告过你们它还没完成，对吧？好的。

哦，我想如果演示在点击 GitHub 按钮的时候失败了，那就太搞笑了。好的。再见了，再见了。我保证下次它能行。好久没干这个了，等等。哦，我快完成了，我的承诺。加油，你之前表现得那么好。更改可见性。是的，我想要……是的，我已阅读并理解……天哪，天哪。是的，在 Dagger，我们非常重视安全。

好的，我想它……等等，我想它完成了。

是的！好的。非常感谢大家。它的地址是 `github.com/dagger/container-use`。欢迎来打个招呼，参与进来。非常感谢你们的邀请！
