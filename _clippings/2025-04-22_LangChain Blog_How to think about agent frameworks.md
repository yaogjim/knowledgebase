---
title: "How to think about agent frameworks"
source: "https://blog.langchain.dev/how-to-think-about-agent-frameworks/"
author:
  - "[[LangChain Blog]]"
published: 2025-04-21
created: 2025-04-22
description: "TL;DR: * The hard part of building reliable agentic systems is making sure the LLM has the appropriate context at each step. This includes both controlling the exact content that goes into the LLM, as well as running the appropriate steps to generate relevant content. * Agentic systems consist of both"
tags:
  - "clippings"
---
**TL;DR:**

- **构建可靠的智能系统的难点在于确保LLM在每一步都有适当的上下文。这包括控制进入LLM的确切内容，以及运行适当的步骤以生成相关内容。**
- **能动系统由工作流和智能体（以及两者之间的所有内容）组成。**
- **大多数智能体框架既不是声明式也不是命令式编排框架，而仅仅是一组智能体抽象。**
- **代理抽象可以使入门变得容易，但它们通常会模糊问题，并且难以确保在每一步中LLM都有适当的上下文。**
- **各种形状和大小的智能系统（智能体或工作流）都受益于同一组有用的功能，这些功能可以由框架提供，也可以从头构建。**
- **LangGraph 最好被视为一个编排框架（具有声明式和命令式 API），其之上构建了一系列代理抽象。**

OpenAI 最近发布了一份关于构建智能体的指南，其中包含一些如下所示的误导性观点：

![](https://blog.langchain.dev/content/images/2025/04/Go0FliaXoAANDWD.jpeg)

这个标注一开始让我很生气，但在开始写回复后我意识到：思考智能体框架很复杂！可能有 100 种不同的智能体框架，有很多不同的比较维度，有时它们会被混淆（就像在这句话中）。外面有很多炒作、姿态和噪音。关于智能体框架的精确分析或思考非常少。这篇博客就是我们为此所做的尝试。我们将涵盖：

- **背景信息**
	- 什么是智能体？
	- 构建智能体的难点是什么？
	- 什么是 LangGraph？
- **智能体框架的类型**
	- “代理”与“工作流”
	- 声明式与非声明式
	- 智能体抽象
	- 多智能体
- **常见问题**
	- 一个框架的价值是什么？
	- 随着模型变得更好，一切都会变成智能体而不是工作流吗？
	- OpenAI 在他们的观点中哪里出错了？
	- 所有的智能体框架如何比较？

在整个博客中，我将多次提及一些材料：

- OpenAI 关于构建智能体的指南（我认为它不是特别好）
- Anthropic 关于构建有效智能体的指南（我非常喜欢）
- LangGraph（我们用于构建可靠智能体的框架）

## 背景信息

为博客的其余部分奠定基础的有用背景信息。

## 什么是智能体

对于智能体没有一致的定义，并且人们常常从不同角度看待它们。

OpenAI 采用了一种更高级、更具思想引领性的方法来定义智能体。

> 代理是代表您独立完成任务的系统。

就我个人而言，我不喜欢这个。这是一个模糊的表述，并没有真正帮助我理解什么是智能体。这只是思想领导力，根本不实用。

将此与 Anthropic 的定义进行比较：

> “智能体”可以有多种定义方式。一些客户将智能体定义为完全自主的系统，这些系统可以长时间独立运行，使用各种工具来完成复杂任务。另一些人则用这个术语来描述遵循预定义工作流程的更具规范性的实现方式。在 Anthropic，我们将所有这些变体归类为智能体系统，但在工作流程和智能体之间做出了重要的架构区分：  
>   
> 工作流是通过预定义代码路径编排LLMs和工具的系统。  
>   
> 另一方面，智能体是这样的系统，其中LLMs动态地指导自身的进程和工具使用，保持对其完成任务方式的控制。

出于几个原因，我更喜欢 Anthropic 的定义：

- 他们对智能体的定义要精确得多且更具技术性。
- 他们还提到了“代理系统”的概念，并将工作流和代理都归类为其变体。我喜欢这个。

💡

我们在生产中看到的几乎所有“智能系统”都是“工作流”和“智能体”的组合。

在博客文章的后面，Anthropic 将智能体定义为“……通常只是LLMs在一个循环中根据环境反馈使用工具。”

![](https://blog.langchain.dev/content/images/2025/04/58d9f10c985c4eb5d53798dea315f7bb5ab6249e-2401x1000.webp)

尽管他们一开始对智能体的定义很宏大，但这基本上也是 OpenAI 的意思。

这些类型的代理由以下内容进行参数化：

- 要使用的模型
- 要使用的说明（系统提示）
- 要使用的工具

你在一个循环中调用模型。如果/当它决定调用一个工具时，你运行该工具，获取一些观察结果/反馈，然后将其传递回LLM。你一直运行，直到LLM决定不再调用工具（或者它调用了一个触发停止标准的工具）。

OpenAI 和 Anthropic 都指出工作流是一种与智能体不同的设计模式。在那里，LLM的控制权较小，流程更具确定性。这是一个有用的区别！

OpenAI 和 Anthropic 都明确指出，并非总是需要智能体。在许多情况下，工作流程更简单、更可靠、更便宜、更快且性能更高。Anthropic 帖子中的一句很棒的话：

> 使用LLMs构建应用程序时，我们建议找到尽可能简单的解决方案，仅在必要时增加复杂性。这可能意味着根本不构建智能系统。智能系统通常会以延迟和成本为代价来换取更好的任务性能，您应该考虑这种权衡何时是合理的。  
>   
> 当需要更高的复杂性时，工作流为定义明确的任务提供可预测性和一致性，而在大规模需要灵活性和模型驱动的决策时，智能体是更好的选择。

OpenAI 表示类似的话：

> 在致力于构建智能体之前，请确认你的用例能够明确满足这些标准。否则，一个确定性的解决方案可能就足够了。

在实践中，我们发现大多数“智能体系统”都是工作流和智能体的组合。这就是为什么实际上我讨厌讨论某事物是否是一个智能体，而是更喜欢讨论一个系统有多智能。感谢伟大的吴恩达提供这种思考方式：

> 与其必须以二元方式选择某事物是否为智能体，我认为，将系统视为在不同程度上类似智能体更有用。与名词“智能体”不同，形容词“具有智能体特征的”使我们能够思考这类系统，并将它们都纳入这一不断发展的趋势中。

## 构建智能体的难点是什么？

我认为大多数人都会认同构建智能体很难。或者更确切地说——将智能体作为原型构建很容易，但要构建一个可靠的、能够为关键业务应用程序提供支持的智能体呢？那就很难了。

棘手的部分恰恰在于此——使其可靠。你可以轻松制作一个在推特上看起来不错的演示。但你能让它运行以支持关键业务应用程序吗？不付出大量努力可不行。

几个月前，我们对智能体构建者进行了一项调查，并问他们：“在生产中部署更多智能体的最大限制是什么？”到目前为止，最常见的回答是“性能质量”——让这些智能体正常工作仍然非常困难。

![](https://blog.langchain.dev/content/images/2025/04/67347b1aed9686aad4544fef_9.-What-is-your-biggest-limitation.svg)

是什么导致智能体有时表现不佳？LLM 出故障了。

为什么LLM会出错？两个原因：(a) 模型不够好，(b) 传递给模型的上下文错误（或不完整）。

根据我们的经验，这很常见于第二个用例。是什么导致了这种情况？

- 不完整或简短的系统消息
- 模糊的用户输入
- 无法使用正确的工具
- 糟糕的工具描述
- 未在正确的上下文中传入
- 格式错误的工具响应

💡

****构建可靠的智能系统的难点在于确保LLM在每一步都有适当的上下文。这包括控制进入LLM的确切内容，以及运行适当的步骤以生成相关内容。****

当我们讨论智能体框架时，记住这一点会很有帮助。任何使精确控制传递给LLM的内容变得更困难的框架都只会妨碍你。将正确的上下文传递给LLM已经够难了——你为什么还要给自己找麻烦呢？

## 什么是 LangGraph

💡

LangGraph 最好被视为一个编排框架（具有声明式和命令式 API），其之上构建了一系列代理抽象。

LangGraph 是一个用于构建智能系统的事件驱动框架。使用它的两种最常见方式是通过：

- 一种声明式的、基于图形的语法
- 代理抽象（构建在较低级别的框架之上）

LangGraph 还支持函数式 API 以及底层的事件驱动 API。有 Python 和 TypeScript 两种变体。

智能系统可以表示为节点和边。节点表示工作单元，而边表示转换。节点和边只不过是普通的 Python 或 TypeScript 代码——因此，虽然图的结构以声明方式表示，但图逻辑的内部功能是普通的命令式代码。边可以是固定的或有条件的。所以虽然图的结构是声明式的，但通过图的路径可以是完全动态的。

LangGraph 附带一个内置的持久层。这实现了容错、短期记忆和长期记忆。

此持久层还支持“人工介入”和“人工参与”模式，如中断、批准、恢复和时间旅行。

LangGraph 对以下流具有内置支持：令牌流、节点更新流和任意事件流。

LangGraph 与 LangSmith 无缝集成，用于调试、评估和可观测性。

## 智能体框架的类型

智能体框架在几个维度上有所不同。理解并不要混淆这些维度是能够正确比较智能体框架的关键。

## 工作流与代理

大多数框架都包含更高级别的智能体抽象。一些框架包含了针对常见工作流的一些抽象。LangGraph 是一个用于构建智能体系统的低级编排框架。LangGraph 支持工作流、智能体以及介于两者之间的任何内容。我们认为这至关重要。如前所述，生产环境中的大多数智能体系统都是工作流和智能体的组合。一个可用于生产的框架需要同时支持这两者。

让我们记住构建可靠智能体的难点所在——确保LLM拥有正确的上下文。工作流之所以有用，部分原因在于它能轻松地将正确的上下文传递给LLMs。你可以精确决定数据的流动方式。

当你思考要在“工作流”到“代理”的范围内何处构建应用程序时，有两件事需要考虑：

- 可预测性与自主性
- 低地板，高天花板

**可预测性与自主性**

随着你的系统变得更具自主性，它将变得更难预测。

有时，出于用户信任、监管原因或其他因素，你希望或需要你的系统具有可预测性。

可靠性与可预测性并非完全同步，但在实际中它们可能密切相关。

在这条曲线上你希望处于的位置非常取决于你的应用程序。LangGraph 可用于在这条曲线的任何位置构建应用程序，使你能够移动到曲线上你希望处于的点。

![](https://blog.langchain.dev/content/images/2025/04/Screenshot-2025-04-20-at-10.43.31-AM.png)

**高层，低天花板**

在思考框架时，考虑它们的下限和上限可能会有所帮助：

- 低地板：低地板框架对初学者很友好，易于上手
- 高层级：具有高层级的框架意味着它有陡峭的学习曲线，并且需要大量知识或专业技能才能开始有效地使用它。
- 低天花板：一个具有低天花板的框架意味着它在使用它所能完成的事情上存在限制（你很快就会超越它）。
- 高天花板：高天花板框架为高级用例提供了广泛的功能和灵活性（它会随着你的需求增长吗？）

工作流框架上限很高，但下限也高——你必须自己编写大量的代理逻辑。

代理框架入门门槛低，但上限也低——易于上手，但对于复杂用例来说不够用。

LangGraph 旨在具备低门槛（内置代理抽象，便于入门）但同时高天花板（实现高级用例的低级功能）的特性。

## 声明式与非声明式

声明式框架有其优点。也有缺点。这在程序员中似乎是一场无休止的争论，每个人都有自己的偏好。

当人们说非声明式时，他们通常暗示着将命令式作为替代。

大多数人会将 LangGraph 描述为一个声明式框架。但这只是部分正确。

首先 - 虽然节点和边之间的连接是以声明式方式完成的，但实际的节点和边只不过是 Python 或 TypeScript 函数。因此，LangGraph 有点像是声明式和命令式的混合体。

其次 - 除了推荐的声明式 API 之外，我们实际上还支持其他 API。具体来说，我们支持函数式和事件驱动的 API。虽然我们认为声明式 API 是一种有用的思维模式，但我们也认识到它并不适用于所有人。

关于 LangGraph 的一个常见评论是，它类似于 TensorFlow（一个声明式深度学习框架），而像 Agents SDK 这样的框架则类似于 PyTorch（一个命令式深度学习框架）。

这是不正确的。像 Agents SDK（以及原始的 LangChain、CrewAI 等）这样的框架既不是声明式的也不是命令式的——它们只是抽象。它们有一个智能体抽象（一个 Python 类），并且它包含了一堆运行智能体的内部逻辑。它们并不是真正的编排框架。它们只是抽象。

## 智能体抽象

大多数智能体框架都包含一个智能体抽象。它们通常从一个涉及提示、模型和工具的类开始。然后添加更多参数……接着再添加一些……然后甚至更多。最终，你会得到一连串控制众多行为的参数，所有这些都在一个类的背后进行抽象。如果你想了解发生了什么，或者更改逻辑，就必须进入类并修改源代码。

💡

这些抽象最终使得在所有步骤中准确理解或控制进入LLM的内容变得极其困难。这一点很重要——拥有这种控制权对于构建可靠的智能体至关重要（如上文所述）。这就是智能体抽象的危险所在。

我们是吃了苦头才学到这一点的。这就是原始的 LangChain 链和智能体存在的问题。它们提供的抽象反而碍事。两年前的那些原始抽象概念之一是一个智能体类，它接受一个模型、提示和工具。这不是一个新概念。当时它没有提供足够的控制权，现在也没有。

需要明确的是，这些智能体抽象有一定价值。它使入门变得更容易。但我认为这些智能体抽象还不足以构建可靠的智能体（也许永远都不够）。

我们认为，思考这些智能体抽象的最佳方式类似于 Keras。它们提供了更高级别的抽象，以便轻松入门。但至关重要的是，要确保它们构建在较低级别的框架之上，这样你才不会在发展过程中超越它。

这就是为什么我们在 LangGraph 之上构建了智能体抽象。这提供了一种轻松开始使用智能体的方法，但如果你需要深入到更低级别的 LangGraph，你也可以轻松做到。

## 多智能体

通常情况下，智能体系统不止包含一个智能体，而是会包含多个。OpenAI 在其报告中表示：

> 对于许多复杂的工作流程而言，在多个智能体之间拆分提示和工具可提高性能和可扩展性。当你的智能体无法遵循复杂的指令或始终选择错误的工具时，你可能需要进一步划分你的系统并引入更多不同的智能体。

💡

多智能体系统的关键部分在于它们如何进行通信。同样，构建智能体的难点在于获得正确的上下文以达到LLMs。这些智能体之间的通信很重要。

有很多方法可以做到这一点！接力是一种方法。这是我非常喜欢的来自代理软件开发工具包的一种代理抽象。

但这些智能体进行通信的最佳方式有时可能是工作流。以 Anthropic 博客文章中的所有工作流图为例，将LLM调用替换为智能体。工作流和智能体的这种结合通常能提供最佳的可靠性。

![](https://blog.langchain.dev/content/images/2025/04/7418719e3dab222dccb379b8879e1dc08ad34c78-2401x1000.webp)

再一次——智能体系统不仅仅是工作流程，也不仅仅是一个智能体。它们可以是——而且通常是——两者的结合。正如 Anthropic 在其博客文章中所指出的：

> **组合并自定义这些模式**  
>   
> 这些构建块并非规定性的。它们是常见的模式，开发人员可以对其进行塑造和组合以适应不同的用例。

## 常见问题

在定义并探讨了你应该基于哪些不同轴来评估框架之后，现在让我们尝试回答一些常见问题。

## 一个框架的价值是什么？

我们经常看到人们质疑他们是否需要一个框架来构建智能系统。智能框架能提供什么价值？

**智能体抽象**

框架通常很有用，因为它们包含有用的抽象，这些抽象使入门变得容易，并为工程师提供了一种通用的构建方式，从而使项目的引入和维护更加容易。如上所述，代理抽象也存在实际的缺点。对于大多数代理框架来说，这是它们提供的唯一价值。我们非常努力地确保 LangGraph 不是这种情况。

**短期记忆**

如今，大多数智能体应用都涉及某种多轮（例如聊天）组件。LangGraph 提供了可用于生产的存储，以实现多轮体验（线程）。

**长期记忆**

虽然还为时过早，但我对智能系统从其经验中学习（例如在对话中记住事情）非常乐观。LangGraph 为跨线程内存提供了可用于生产的存储。

**人工参与循环**

许多智能体系统通过一些人工参与的组件会变得更好。示例包括从用户那里获取反馈、批准工具调用或编辑工具调用参数。LangGraph 提供了内置支持，以便在生产系统中启用这些工作流程。

**人工参与**

除了允许用户在智能体运行时对其产生影响外，允许用户在事后检查智能体的轨迹，甚至回到早期步骤并从那里重新运行（进行更改）也可能很有用。我们将此称为“人工参与循环”，LangGraph 对此提供了内置支持。

**流**

大多数智能应用程序运行需要一些时间，因此向终端用户提供更新对于提供良好的用户体验至关重要。LangGraph 提供了内置的令牌流、图步骤流和任意流。

**调试/可观测性**

构建可靠智能体的难点在于确保你向LLM传递了正确的上下文。能够检查智能体采取的具体步骤以及每一步的确切输入/输出对于构建可靠智能体至关重要。LangGraph 与 LangSmith 无缝集成，以实现一流的调试和可观测性。注意：人工智能可观测性与传统软件可观测性不同（这值得单独写一篇文章）。

**容错**

容错是构建分布式应用程序的传统框架（如 Temporal）的关键组成部分。LangGraph 通过持久化工作流和可配置的重试机制使容错变得更加容易。

**优化**

与其手动调整提示，有时定义一个评估数据集，然后基于此自动优化智能体可能会更容易。LangGraph 目前还不支持开箱即用的此功能——我们认为现在考虑这个还为时过早。但我想提及这一点，因为我认为这是一个值得考虑的有趣方面，也是我们一直在密切关注的事情。 `dspy` 是目前对此最好的框架。

💡

所有这些价值主张（除了代理抽象之外）都为代理、工作流以及两者之间的所有事物提供了价值。

**那么 - 你真的需要一个能动框架吗？**

如果你的应用程序不需要所有这些功能，和/或如果你想自己构建它们，那么你可能不需要一个。其中一些功能（如短期记忆）并不是非常复杂。其他一些功能（如人工参与或LLM特定可观测性）则更复杂。

关于智能体抽象：我同意 Anthropic 在他们的帖子中所说的：

> 如果你确实使用了一个框架，确保你理解其底层代码。对框架底层内容的错误假设是客户出错的常见原因。

## 随着模型变得更好，一切都会变成智能体而不是工作流吗？

支持代理（与工作流相比）的一个常见论点是，虽然它们现在不起作用，但将来会起作用，因此你只需要简单的、调用工具的代理。

我认为多种情况可能是真的：

- 这些工具调用代理的性能将会提高
- 能够控制输入到LLM中的内容（输入垃圾，输出垃圾）仍然非常重要
- 对于某些应用程序来说，这个工具调用循环就足够了
- 对于其他应用程序而言，工作流程将变得更简单、更便宜、更快速且更出色
- 对于大多数应用程序而言，生产代理系统将是工作流和代理的组合

我不认为 OpenAI 或 Anthropic 会对这些观点中的任何一点提出异议？来自 Anthropic 的帖子：

> 使用LLMs构建应用程序时，我们建议找到尽可能简单的解决方案，仅在必要时增加复杂性。这可能意味着根本不构建智能系统。智能系统通常会以延迟和成本为代价来换取更好的任务性能，您应该考虑这种权衡何时是合理的。

以及来自 OpenAI 的帖子：

> 在致力于构建智能体之前，请确认你的用例能够明确满足这些标准。否则，一个确定性的解决方案可能就足够了。

是否存在一些应用场景，仅靠这种简单的工具调用循环就足够了？我认为只有在你使用基于大量特定于用例的数据进行训练/微调/强化学习的模型时，才可能如此。这可能通过两种方式实现：

- 你的任务很独特。你收集大量数据并训练/微调/强化学习你自己的模型。
- 你的任务并非独一无二。大型模型实验室正在使用代表你任务的数据进行训练/微调/强化学习。

（附注：如果我在一个我的任务并非独一无二的领域创办一家垂直型初创公司，我会非常担心我的初创公司的长期可行性。）

**你的任务是独一无二的**

我敢打赌，大多数用例（当然是大多数企业用例）都属于这一类别。爱彼迎处理客户支持的方式与 klarna 不同，而 klarna 处理客户支持的方式又与乐天不同。这些任务中有大量的微妙之处。Sierra——客户支持领域的一家领先代理公司——并不是在构建单个客户支持代理，而是在构建一个客户支持代理平台：

> Sierra Agent SDK 使开发人员能够使用声明式编程语言，通过可组合技能来构建强大、灵活的智能体，以表达过程性知识

他们需要这样做，因为每个公司的客户支持体验都足够独特，以至于通用代理的表现不够好。

一个使用在特定任务上训练的模型的简单工具调用循环智能体的例子：OpenAI 的深度研究。所以这是可以做到的，并且可以产生惊人的智能体。

如果你能在特定任务上训练出一个 SOTA 模型——那么是的，你可能不需要一个支持任意工作流程的框架，你只需使用一个简单的工具调用循环。在这种情况下，相比于工作流程，智能体将更受青睐。

在我心中一个非常开放的问题是：有多少代理公司会拥有为其任务训练一个 SOTA 模型的数据、工具或知识？就在此刻，我认为只有大型模型实验室能够做到这一点。但这种情况会改变吗？一家小型垂直领域初创公司能够为其任务训练一个 SOTA 模型吗？我对这个问题非常感兴趣。如果你目前正在做这件事——请联系我！

**你的任务并非独一无二**

我认为有些任务足够通用，以至于大型模型实验室将能够提供足够好的模型，以便在这些非通用任务上执行简单的工具调用循环。

OpenAI 通过 API 发布了他们的计算机使用模型，这是一个基于通用计算机使用数据进行微调的模型，旨在在该通用任务上表现出色。（附注：我认为它目前还远远不够好。）

代码就是一个有趣的例子。编码相对来说比较通用，而且到目前为止，编码绝对是智能体的一个突破性用例。Claude 代码和 OpenAI 的 Codex CLI 就是使用这种简单工具调用循环的编码智能体的两个例子。我敢打赌，基础模型是在大量编码数据和任务上进行训练的（见这里的证据表明 Anthropic 是这样做的）。

有趣的是——由于通用模型是基于这些数据进行训练的，那么这些数据的确切形态有多重要呢？本·海拉克前几天发了一条有趣的推文，似乎引起了大家的共鸣：

> 模型不再知道如何使用光标了。  
>   
> 它们都针对终端进行了优化。这就是为什么 3.7 版本和启用 O3 优化在 Cursor 中表现如此糟糕，而在其他地方却如此出色的原因。

这可能意味着两件事：

- 你的任务必须与通用模型所训练的任务非常非常接近。你的任务与通用模型所训练的任务越不相似，通用模型就越不太可能满足你的用例需求。
- 在其他特定任务上训练通用模型可能会降低你任务的性能。我敢肯定，用于训练新模型的与 Cursor 用例类似的数据（如果不是更多的话）同样多。但是，如果有这种形状略有不同的新数据涌入，它就会超过任何其他类型的数据。这意味着目前通用模型很难在大量任务上真正表现出色。

💡

即使对于那些更倾向于使用智能体而非任何类似工作流的应用程序，你仍将受益于框架中与低级工作流控制无关的功能：短期内存存储、长期内存存储、人工参与、人工介入、流处理、容错、调试/可观测性。

## OpenAI 在他们的观点中哪里出错了？

如果我们重新审视 OpenAI 的立场，就会发现它基于错误的二分法，这些二分法将“智能体框架”的不同维度混为一谈，以夸大其单一抽象的价值。具体来说，它将“声明式与命令式”与“智能体抽象”以及“工作流与智能体”混为一谈。

💡

最终，它没有抓住构建生产性智能体系统的主要挑战以及框架应提供的主要价值，即：一个可靠的编排层，它能让开发者对进入其LLMs的上下文有明确的控制权，同时无缝处理诸如持久性、容错性和人工参与交互等生产方面的问题。

让我们剖析一下我有异议的具体部分：

![](https://blog.langchain.dev/content/images/2025/04/Go0FliaXoAANDWD-1.jpeg)

**”声明式与非声明式图形”**

LangGraph 并非完全声明式的——但它声明式的程度足以让这不是我主要的不满之处。我主要的不满在于“非声明式”做了很多工作且具有误导性。通常当人们批评声明式框架时，他们会更喜欢一个更命令式的框架。但代理软件开发工具包（Agents SDK）不是一个命令式框架。它是一种抽象。根据他们想要争论的内容（他们似乎在下面两者都有争论），一个更合适的标题可以是“声明式与命令式”或“你需要一个编排框架吗”或“为什么代理抽象就是你所需要的一切”或“工作流与代理”

**随着工作流程变得更加动态和复杂，这种方法很快就会变得繁琐且具有挑战性**

这与声明式或非声明式无关。这完全与工作流和代理有关。你可以轻松地在代理软件开发工具包中将代理逻辑表示为声明式图形，并且该图形与代理软件开发工具包一样动态且灵活。

关于工作流与智能体的问题。很多工作流并不需要这种程度的动态性和复杂性。OpenAI 和 Anthropic 都承认这一点。当可以使用工作流时，就应该使用工作流。大多数智能体系统都是两者的结合。没错，如果一个工作流真的动态且复杂，那就使用智能体。但不要事事都用智能体。OpenAI 在论文前面确实提到过这一点。

**通常需要学习特定领域的专业语言**

再说一次 - 代理软件开发工具包不是一个命令式框架。它是一种抽象。它还有一种特定领域语言（它的抽象）。我认为，在这个时间点上，必须学习并围绕代理软件开发工具包的抽象进行工作，比必须学习 LangGraph 抽象更糟糕。很大程度上是因为构建可靠代理的难点在于确保代理具有正确的上下文，而代理软件开发工具包比 LangGraph 更能混淆这一点。

**更灵活**

这绝对不是真的。这与事实恰恰相反。使用 Agents SDK 能做的一切，使用 LangGraph 都能做到。Agents SDK 只能让你完成使用 LangGraph 所能完成之事的 10%。

**“代码优先”**

使用代理软件开发工具包（Agents SDK），你编写它们的抽象。使用语言图（LangGraph），你编写大量常规代码。我不明白代理软件开发工具包（Agents SDK）怎么就更是以代码优先了。

**使用熟悉的编程结构**

使用代理软件开发工具包（Agents SDK），你必须学习一整套全新的抽象概念。使用 LangGraph，你只需编写大量常规代码。还有什么比这更熟悉的呢？

**实现更具动态性和适应性的代理编排**

再一次 - 这与声明式与非声明式无关。这与工作流程与代理有关。见上述要点。

## 比较智能体框架

我们已经讨论了智能体框架的许多不同组件：

- 它们是灵活的编排层，还是仅仅是一种代理抽象？
- 如果它们是一个灵活的编排层，那么它们是声明式的还是其他方式的？
- 除了智能体抽象之外，这个框架还提供了哪些功能？

我觉得试着在电子表格中列出这些维度会很有趣。对此我尽量做到公正（我在推特上征求了很多意见，也得到了很多很好的反馈！）

这目前包含与 Agents SDK、谷歌的 ADK、LangChain、Crew AI、LlamaIndex、Agno AI、Mastra、Pydantic AI、AutoGen、Temporal、SmolAgents、DSPy 的比较。

如果我遗漏了某个框架（或者对某个框架的理解有误），请留下评论！

💡

你可以在这里找到该电子表格的实时版本。

## 结论

- **构建可靠的智能系统的难点在于确保LLM在每一步都有适当的上下文。这包括控制进入LLM的确切内容，以及运行适当的步骤以生成相关内容。**
- **能动系统由工作流和智能体（以及两者之间的所有内容）组成。**
- **大多数智能体框架既不是声明式也不是命令式编排框架，而仅仅是一组智能体抽象。**
- **代理抽象可以使入门变得容易，但它们通常会模糊问题，并且难以确保在每一步中LLM都有适当的上下文。**
- **各种形状和大小的智能系统（智能体或工作流）都受益于同一组有用的功能，这些功能可以由框架提供，也可以从头构建。**
- **LangGraph 最好被视为一个编排框架（具有声明式和命令式 API），其之上构建了一系列代理抽象。**